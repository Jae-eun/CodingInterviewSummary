# 프로세스란?

프로그램의 명령어와 정적 데이터가 메모리에 `적재`되면 생명이 있는 `프로세스`이다.

=> `실행 중인 프로그램`



* 프로그램

  > 보조 기억장치(하드디스크, SSD)에 존재하며, 실행되기를 기다리는 명령어(코드)와 정적인 데이터의 묶음



# 어떻게 여러 개의 프로세스가 동시에 실행될 수 있을까?

> 하나의 CPU(프로세서)는 한 순간에 하나의 프로세스만 실행할 수 있다.

`운영체제`가 매우 빠르게 CPU가 실행할 프로세스를 교체하고 있기 때문이다.



# 프로세스는 어떻게 구성되어 있을까?

프로세스에 대한 정보는 **프로세스 제어블록(PCB, Process Control Block)** 또는 **프로세스 기술자(process descriptor)**라고 부르는 자료구조에 저장됨. PID, 프로그램 정보, 상태, 순위 등을 저장하고 있음.



* **PID(Process IDentification)**

  > 운영체제가 각 프로세스를 식별하기 위해 부여된 프로세스 식별번호

* **프로세스 상태**

  > 실행 중이거나 대기 중인지

* **프로그램 카운터**

  > CPU가 다음으로 실행할 기계어가 저장된 메모리 주소를 가리키는 값

* **스케줄링 우선순위**

  > 여러 개의 프로세스가 CPU에서 실행되는 순서

* **권한**

  > 프로세스가 접근할 수 있는 자원을 결정하는 정보

* **프로세스의 부모와 자식 프로세스**

  > 모든 프로세스는 부모 프로세스를 복제해서 생성됨. 이 계층관계는 트리를 형성함. (최초로 생성되는 init 프로세스 제외)

* **프로세스의 데이터와 명령어가 있는 메모리 위치를 가리키는 포인터**

* **프로세스에 할당된 자원들을 가리키는 포인터**

* **실행 문맥**

  > 프로세스가 실행 상태에서 마지막으로 실행한 프로세서의 레지스터 내용. 프로세스가 교체될 때 연속적으로 실행된 것처럼 하기 위해 갖고 있음.





# 프로세스가 접근할 수 있는 메모리 공간

![](https://t1.daumcdn.net/cfile/tistory/2453685056EEACBE22)





# 프로세스는 어떻게 관리될까?

운영체제는 프로세스를 교체하고 재시작할 때 오류가 발생하지 않도록 프로세스의 상태를 `실행(running)`, `준비(ready)`, `블록(block)` 상태로 분류하고 프로세스들을 `상태전이(state trasition)` 를 통해 체계적으로 관리함.



1. 사용자가 프로그램을 실행하면 프로세스가 생성되고 준비리스트에 추가됨.

2. 프로세스는 프로세서(CPU)가 사용 가능한 상태가 되면 할당 받음.

3. 준비 상태에서 실행 상태로 상태전이됨(`디스패칭(dispatching)`)

4. 프로세스는 실행 상태에서 CPU를 이용해 연산 후 자발적으로 반납하고 작업이 끝나지 않았으면 `다시 준비상태` 에 들어감.

5. 프로세스를 다시 사용하기 전에 입출력이 완료되기를 기다려야 하는 상황이면 완료될 때까지 자신을 `블록` 함. 



# 프로세스가 CPU를 독점하는 경우를 방지하기 위해 어떻게 할까?

운영체제는 하드웨어적으로 `인터럽팅 클록` 을 주기적으로 발생시켜 프로세스가 **특정 시간 간격동안** 만 실행할 수 있도록 함. 운영체제는 강제로 실행중인 프로세스의 CPU 제어권을 뺏고 프로세스는 준비 상태로 상태전이됨.























